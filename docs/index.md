# What is TrcLib?

The Titan Robotics Framework (TrcLib) is an all-in-one software solution designed for FTC and FRC robotics competitions. It provides robust support for subsystems, path following, and vision processing all built on a multi-threaded structure developed over 23 years of competitive experience. Through years of iteration, the library has grown to include over 33,000 lines of code. The goal of the framework is to offer a complete robot template structure (FtcTemplate), providing everything a robotics team needs to get up and running efficiently.

TrcLib provides simple interfaces for writing clean, easy-to-use code, while handling all the complex backend logic for you:

* **Vision**: The Framework supports an all-in-one object detection setup using OpenCV or Limelight, and also includes complete object localization through AprilTags. 

* **Task Management**: TrcLib offers a powerful task management system, built with state machines, multi-threading, and an advanced event system. This allows users to perform parallel or asynchronous actions in any order or structure—all through simple, intuitive interfaces.

* **Path Following**: The Framework features multiple fast and accurate path-following algorithm, compatible with most drive bases and odometry systems.

* **Subsystems**: With a clean and straightforward class structure, the Framework handles all multitasking behind the scenes. Users can easily set up subsystem classes that unlock dozens of helpful motor and servo APIs not available in the standard FTC SDK.

If you'd like to explore more of what the Robotics Framework has to offer, check out the [Library Features](#library-features) section, where we dive deeper into its capabilities and benefits.

## Framework Library JavaDoc

* [FtcLib JavaDoc](https://trc492.github.io/FtcJavaDoc/index.html)

## Frequently Asked Questions

* Questions and Answer will be added as needed!

[As i have people test the docs, when they ask good question that does not have a good palce to be answered i will add them here]: #

## Library Features

Our Framework Library offers a wide range of advanced features, streamlined to be simple and intuitive for the end user, including:

* **Advanced Multi-Tasking**: Our own opmode that extends LinearOpMode but providing interface similar to OpMode where you put your code in some sort of loop method. FtcOpMode is a cooperative multi-tasking scheduler. As an advanced feature, our Framework Library also supports multi-threaded true multi-tasking. The Library provides a number of standard threads (i.e. main robot thread and IO thread). If there is a special need that either requires high frequency processing and cannot afford any latency or a task that takes extra long time to run and thus blocking the thread unnecessarily long, the Library enables you to create STANDALONE tasks that have their own thread. All these tasks/threads are mananged by the Task Manager (TrcTaskMgr). Multi-tasking allows your autonomous to operate multiple subsystems at the same time instead of doing things sequentially, allowing for the maximum number of operation in the shortest period of time. 

* **State Machine**: The state machine infrastructure is the core of multi-tasking. Each task should use a state machine to keep track of their states. This allows FtcOpMode to switch between tasks and be able to maintain the state of each task when they are resumed from suspended state.

* **Task Synchronization**: Some tasks have dependencies on each other. This requires task synchronization. The Framework Library provides a number of task synchronization features such as Events (TrcEvent) and Callbacks (TrcEvent.Callback). Event allows an operation to signal it when the operation is completed so that the task waiting for it can resume. Callback allows a method to be called to perform additional work without the use of a state machine after the operation is completed, for example.

* **Pathing Following**: Our library supports a refined version of Pure Pursuit path following. Not only can it follow pre-planned paths, but it also handles dynamically generated ones—perfect for working with vision systems that detect target locations and generate paths on the fly. It uses both motion profiling and PID control to get the robot to its target as quickly and smoothly as possible. The system supports both absolute and incremental path calls, adaptive power limiting and motion profiling,on a per path basis. 

* **Trace logging:** (TrcUtil) In addition of providing information output to the dashboard on the driver station, the Framework Library also provides trace logging mainly for debugging purpose. It is a super important tool allowing post-mortem analysis of the robot performance of a match either for debugging or for performance tuning. Information written to the trace log has different levels that can be adjusted to reduce clutter. The levels are: VERBOSE, DEBUG, INFO, WARNING, ERROR and FATAL. For example, in regular competition match log, we will only turn up to the INFO level at the most. But for debugging, we may turn up to DEBUG or even VERBOSE to see everything.

* **Exclusive Subsystem**: A robot consists of many subsystems (e.g. drive base, elevator, shooter, intake, vision etc). Most of the subsystems can be operated by human operator in TeleOp mode. However, some subsystems can also be used in auto-assist operations. The auto-assist operation involves several subsystems while these subsystems can also be operated by human control. Without coordination, human control and auto-assist may fight each other for the control of these subsystems. Before auto-assist starts an operation with the Exclusive Subsystem, it must acquire exclusive ownership of the subsystem. Once ownership is acquired, nobody else except the owner can operate the subsystem. This prevents teleop control from interfering with the auto-assist operation. When the auto-assist operation is done, the exclusive ownership of the subsystems will be released so that telop control can be resumed.

* **PIDF Control**: Aside from supporting motor native close-loop control, our framework library also supports software PIDF control. Our software PIDF controller has a lot of extra features such as iZone in addition to P.I.D.F. It also understands target tolerance, stalling due to steady state error. It understands absolute versus relative target setpoint. It supports options to disallow oscillation (i.e. if the controller overshoots, it will just stop even though it exceeded tolerance). It also supports setting close-loop ramp rate and stall detection for aborting close-loop control hang (i.e. steady state error exceeding tolerance causing close-loop control to wait forever). It also allows setting close-loop control maximum power limits.

* **Vision**: Computer vision can have different complexity, ranging from simple color blob detection to full blown neural network machine learning object recognition. Fortunately, there are industrial vision libraries that take care of the heavy lifting for us. Libraries such as Tensor Flow, AprilTag and OpenCV. Our Framework Library includes support for all these industrial libraries:

    * **Cv ColorBlob Vision**: The Framework Library supports a powerful yet easy-to-use color blob detection system. Users can sort detected contours in dozens of ways to pinpoint the exact target object they’re looking for.

    * **AprilTag Tag Vision**: With pre-implemented methods, our library can easily return the exact global position of your robot with minimal setup.

    * **Limelight Vision:**: Limelight Vision is our latest addition for TensorFlow support, using its built-in coprocessor and easy-to-create neural detectors. Our Framework supports every pipeline Limelight provides— SnapScript, Neural Classifier, Neural Detector, and AprilTag. Users can easily access all of these pipelines through the Framework.

One problem with vision is it is computational intensive to process an image frame and could take hundreds of milliseconds. 
Some industrial libraries support asynchronous processing of image frames and some do not. For those that don't, they could block our main robot thread for hundreds of milliseconds. But with our Framework Library, we wrap these industrial libraries with easy to use interfaces and provide asynchronous support thus freeing our main robot thread to take care of other tasks. This encapsulation makes it extremely easy to writing vision code.

* **Drive Base**: Our Framework Library provided support for 3 different types of drive bases:

  * **Simple Differential Drive Base:** (TrcSimpleDriveBase) Supports drive bases with 2 to 6 motors. It has left and right sides. Each side can have 1 to 3 motors. Simple Drive Base can only run straight and cannot strafe like Mecanum Drive Bases (i.e. no holonomicDrive support, only differential drive).

  * **Mecanum Drive Base:** (TrcMecanumDriveBase) Has 4 mecanum wheels. Each wheel has its own motor. It is capable of holonomic drive (i.e. strafing).

  * **Swerve Drive Base:** (TrcSwerveDriveBase) Has 4 swerve wheel modules. Each swerve module consists of a drive motor and a steering motor. The steering motor can be a DC motor or a continuous servo motor. Each swerve module on a Swerve Drive Base can be independently steer so that it can run in any direction with the robot heading pointing to a totally different direction.
  
  All drive bases have built-in kinematics, odometry and localization support. As well as supporting many advanced features such as stall detection that detects if the drive base is stalled because it runs into an obstacle. This allows the custom path-following algorithm to detect when it's stuck at an unreachable target, ensuring your robot doesn't get stranded in the middle of autonomous. All drive bases provide support for different drive strategies such as tankDrive, arcadeDrive and curveDrive. It also provides support for holonomicDrive for drive bases that have this capability such as Mecanum and Swerve Drive Bases. For holonomic capable drive bases, it also supports field oriented driving where the robot can go in any direction independent of the robot's heading. It also supports Gyro-Assist driving where it uses the gyro to keep the robot driving straight. If the robot has a weight distribution problem or one of the wheels has more friction than the others, the robot won't drive straight.

* **Drive Base Odometry**: Our drive base odometry support included all the most popular used sesnors including wheel encoders, pinepoint, otos, dead-wheel odometry (supporting 2-4 passive omniwheels), and gyro to keep track of the absolute field location of the robot. It can combine the sensor readings to find the global position of the robot. All odometry data can be scaled to real world unit such as inches instead of encoder counts. 

* **Data Filters and Processors**: In the real world, sensors have noises. In some applications, noises are bad for robot control. The Framework Library provides a number of popular data filters (e.g. IIR, Kalman and Spurious filters etc) that will clean up noises on sensor readings. It also provides some data converters such as data integrator. For example, in some sensors such as some gyros or compasses, they give you non-contiguous readings when passing through some point such as the REV IMU gyro goes from 179 degrees to -180, or compass goes from 359 degrees back to zero. This non-contiguous values may cause havoc in control algorithms. In this case, the Library provides a converter that can monitor the sensor crossing such points and convert the values into a contiguous scale.

* **Motor Odometry**: Motor odometry keeps track of motor position as well as velocity in real world units (e.g. inches) instead of encoder counts. If the motor does not support native velocity report, our library will calculate the velocity for you. Motor odometry is highly optimized for performance. We support Lynx Bulk Caching mode that guarantee reading motor odometry only once in a robot loop. Our code has built-in performance monitors for debugging performance issues.

* **Timers**: The Timer Manager (TrcTimer) manages multiple simultaneous timers. When a timer expires, you have the option of signaling an event or doing an event callback. For example, if you want to spin a motor for 3 seconds and turn it off afterwards, you can arm a timer that expires in 3 seconds and do an event callback to turn the motor off. This type of operation is sometimes called "fire and forget".

* **Inputs**: The Framework Library supports many different input devices such as:

  * **Gamepad controller:** The Framework Library monitor all buttons on the gamepad for state changes. Any button presses or releases will result in an event callback to your button event handler. This simplifies your TeleOp code tremendously.

  * **Sensors**: The Framework Library supports many type of sensors whether they are digital sensors, analog sensors, I2C sensors or even Android built-in sensors, the Library provides access to them. Popular sensors include ultronic sensor, color sensor, distance sensor such as Lidar, gyro, accelerometer, touch sensor, IR seeker and Pixy camera etc. It also supports many underlying communication protocols (e.g. I2C, Serial, SPI etc) so that you can write custom sensor driver code to communicate with sensors that the Library does not have built-in support.

  * **Driver station dashboard:** The Framework Library provides easy access to the driver station as an input device. It allows you to create Choice Menus (FtcChoiceMenu) or Value Menus (FtcValueMenus) where you can ask the user to provide information before the competition match is started. Information such as whether you are on the RED or BLUE Alliance; which starting position your robot is in; whether your robot should delay starting the autonomous routine to let your alliance partner to go first to avoid potential collision or whether your robot should perform or skip a certain autonomous tasks. The Choice and Value menus form a decision tree that allow the user to select choices or enter values using the gamepad buttons.

  * **FtcDashboard:** The Framework also supports the FTC Dashboard, enabling live variable tuning of subsystem and drivebase PIDFs. It also allows real-time variable tracking, letting you graph important data for easier tuning.

* **Outputs**: The Framework Library supports many types of output devices such as motors, servo, complex actuators, lights and sound.

  * **Motors:** Motor is the most fundamental output device on a robot. FTC SDK provides some basic motor classes (e.g. DcMotor, DcMotorEx). The Framework Library adds a lot more features on top of that in different layers of complexity. TrcMotor added support for lower and upper limit switches, motor stall protection for safety, multiple motors with synchronization (motor followers), zero position calibration and gravity compensation. These advanced features made it trivial to implement complex subsystems such as a swing arm or elevator. The built-in PIDF controller allows subsystems to be controlled by an analog joystick to speed up or slow down the subsystems movement depending on how close the lower/upper limits switches are. In addition, it also supports voltage compensation, digital input sensor to reset the motor encoder automatically (limit switches + zero calibrate), added support to provide velocity mode control, and motor odometry. It can support either native motor close-loop control (position and velocity PID control) or software PID control in case some motors do not support native close-loop control (e.g. continuous servos).

  * **Servos:** With the limited number of motors allowed by FTC, servo motors become the secondary important actuator on a robot. The Framework Library provides the basic support of a servo over the FTC SDK (TrcServo). It supports translation between logical servo positions (between the value of 0 and 1) to physical positions such as 0 to 180 degrees. Just like motors, it also allows you to invert the direction of the servo movement. In addition, it also provides features to support multiple servos (followers), continuous servo with optional encoder, lower and upper limit switches. Most importantly, it allows speed controlling a servo motor so you can control a servo by an analog joystick.

  * **Light:** The Framework Library supports many ways to control lights, usually LEDs. They could be a single LED with just one color, a single RGB LED or a RGB LED strip that is pixel addressable. The LED lights can be controlled by digital output ports or most likely the REV Blinkin LED controller. This is not only for asethetics, it also can providing feedback to drivers on robot status. The Library not only allows you to lit up LEDs in different colors or different color patterns, it also provides a complex priority scheme in controlling the LEDs (TrcPriorityIndicator). The Library also provides support for LED Matrix Panel.

  * **Sound:** The Framework Library supports sound. Which is done thought the Driver Station. The support includes playing a tone or providing text to speech. It provides feedback to the drivers on important robot status. For example, if one of the motors is stalled, the Library can cut power to the motor to prevent it from burning out. Sound support can generate a beep to warn the driver about it.

## History of TrcLib

Titan Robotics Club (TRC) was started in 2001 competing in the *FIRST Robotics Competition* (FRC). Starting in the FRC season 2007-2008, the Club decided to develop the Titan Robotics Framework Library (TrcLib) and to make the library open source. At the time, we were using Mercurial as our source control and was hosting the source code on our own Linux server. In 2010, we switched to use Git as our source control and have moved all our repositories to GitHub to free ourselves from maintaining our own source control server. With over a decade of development, TrcLib has become a feature rich Robotics Library. At the beginning, the library was written in C for FRC. In 2009, the Club added the *FIRST Tech Challenge* program (FTC). TrcLib was then ported to RobotC, the programming language for the LEGO Mindstorm platform used by FTC. In 2015, with the introduction of the Android platform in FTC, the Club switched to use Java as the programming language for both FTC and FRC. TrcLib was then rewritten in Java so that the majority of the Library code can be shared between FTC and FRC. At the time of this writing (2021), TrcLib has grown to over 20,000 lines of code with over 12,000 lines shared between FTC and FRC. Aside from the repositories of the FTC and FRC competition seasons, we also created many useful projects on GitHub. In 2016, we created the [TrcFtcSamples](https://github.com/trc492/TrcFtcSamples) repository including lots of sample code helping other FTC teams who decided to use our TrcLib for FTC. This enables rookie teams to write relatively advanced code without too much effort. With that, we also created [JavaDoc](https://trc492.github.io/FtcJavaDoc/) for TrcLib. The recent addition of the [FtcTemplate](https://github.com/trc492/FtcTemplate) and [FrcTemplate](https://github.com/trc492/FrcTemplate) repositories enables FTC and FRC teams to quickly create their own code repository for the new season with the latest copy of TrcLib as well as the FTC/FRC SDK for the season. In the FtcTemplate/FrcTemplate repositories, they comes with basic robot code for three different drive bases (*Differential Drive Base, Mecanum Drive Base and Swerve Drive Base*) with ready to drive TeleOp code.
